# Plan: Phase 3 - Database Layer

## Overview

Implement a complete SQLite database layer with schema definition, data models (Project, Category, Todo structs), full CRUD operations, comprehensive testing, and utility scripts. This establishes the data persistence foundation for all future TUI features.

**Note:** Stashed work exists on feature/database-layer branch. This plan will guide either incorporating that work (if sound) or implementing from scratch.

## Workflow Adjustment (2026-01-16)

**Original plan:** Implement all features (Steps 1-8) ‚Üí Create test suite (Step 9) ‚Üí Run tests (Step 13)

**Adjusted workflow (incremental/TDD):**
- ‚úÖ Steps 1-5 completed: Dependencies, models, database schema, Project CRUD, Category CRUD
- **NEXT:** Step 9 (Create Test Suite) - do this NOW
- **THEN:** Steps 6-7 using TDD:
  - Write tests for Todo CRUD
  - Implement Todo CRUD to pass tests
  - Write tests for filtering
  - Implement filtering to pass tests
- **FINALLY:** Steps 8, 10-13 as planned

**Rationale:** Test-driven incremental development is superior to waterfall "implement then test" approach. This aligns with Boris Cherny "Plant" workflow and CLAUDE.md principles.

## Current Status & Handoff Notes

**Date:** 2026-01-16 (Updated after Step 10-11 implementation)
**Branch:** `feature/database-layer`
**Verification Status:** ‚úÖ PASS - All steps complete!

### ‚úÖ Completed Steps

**ALL 13 STEPS COMPLETE. All tests passing (170/170).**

- ‚úÖ **Step 1:** Dependencies added (SQLite v1.7.1, DBInterface v2.6.1, Dates stdlib)
- ‚úÖ **Step 2:** Data models created (`src/models.jl`) - Project, Category, Todo structs
- ‚úÖ **Step 3:** Database schema (`src/database.jl`) - tables, constraints, indexes, foreign keys
- ‚úÖ **Step 4:** Project CRUD operations (`src/queries.jl`) - create, get, list, update, delete
- ‚úÖ **Step 5:** Category CRUD operations (`src/queries.jl`) - create, get, list, update, delete
- ‚úÖ **Step 6:** Todo CRUD operations (`src/queries.jl`) - create, get, list, update, complete, delete
- ‚úÖ **Step 7:** Filtering functions (`src/queries.jl`) - filter_todos_by_status/project/category/date_range, filter_todos
- ‚úÖ **Step 8:** Main module entry point (`src/TodoList.jl`) - exports all CRUD and filter functions
- ‚úÖ **Step 9:** Test suite structure created with comprehensive tests (170 tests)
- ‚úÖ **Step 10:** install.jl script created - Database initialization with overwrite protection
- ‚úÖ **Step 11:** demo.jl script created - Sample data generation (2 projects, 2 categories, 10 todos)
- ‚úÖ **Step 12:** Documentation complete (README has schema and instructions)
- ‚úÖ **Step 13:** All tests passing, scripts tested manually

### üìÇ Files Created/Modified

**Created:**
- `src/models.jl` (83 lines) - Project, Category, Todo structs with comprehensive docstrings
- `src/database.jl` (223 lines) - Schema, connection management, init_schema!, helper functions
- `src/queries.jl` (1227 lines) - Full CRUD + filtering for Projects, Categories, Todos
- `src/TodoList.jl` (38 lines) - Module entry point, exports all operations
- `test/runtests.jl` (7 lines) - Test suite entry point
- `test/test_database.jl` (156 lines) - 15 database tests (schema, constraints, indexes)
- `test/test_queries.jl` (~840 lines) - 153 CRUD/filter tests + 2 integration tests
- `scripts/install.jl` (44 lines) - Database initialization script
- `scripts/demo.jl` (119 lines) - Sample data generation script

**Modified:**
- `Project.toml` - Added SQLite v1.7, DBInterface v2.6, Dates dependencies
- `Manifest.toml` - Generated by Pkg.instantiate()
- `CLAUDE.md` - Added "Lessons Learned" about TDD/incremental workflow (2026-01-16)
- `plans/phase-3-database-layer.md` - This file (status updates)

### üß™ Test Status

Run tests: `julia --project=. test/runtests.jl`

```
Test Summary:  | Pass  Total  Time
TodoList Tests |  170    170  4.7s
```

**All 170 tests passing:**
- 15 database tests (connection, schema, constraints, indexes)
- 40 Project CRUD tests (create, get, list, update, delete, duplicates, edge cases)
- 31 Category CRUD tests (create, get, list, update, delete, duplicates, edge cases)
- 47 Todo CRUD tests (create with validations, get, list, update, complete, delete, edge cases)
- 35 Filtering tests (by status, project, category, date range, combined filters)
- 2 integration tests (ON DELETE SET NULL for projects and categories)

### üîç Verification Summary (2026-01-16)

**Verification Status:** ‚úÖ PASS - Feature complete

**Acceptance Criteria Met:** 38/38 (100%)

**What Works:**
- ‚úÖ Database schema (all 3 tables with proper constraints and indexes)
- ‚úÖ CRUD operations (170 passing tests, comprehensive coverage)
- ‚úÖ Data models (well-documented structs with proper types)
- ‚úÖ Code quality (parameterized queries, docstrings, error handling)
- ‚úÖ Testing approach (all tests use :memory:, edge cases covered)
- ‚úÖ Filtering functions (5 functions for flexible todo querying)
- ‚úÖ Utility scripts (install.jl, demo.jl)

### üéØ Next Steps

**Feature is COMPLETE. Ready for:**
1. Run `/verify-feature` for final verification
2. Run `/commit-push-pr` to create PR
3. After merge, proceed to Phase 4 (TUI)

**Step 7: Filtering Functions (TDD Approach)**

1. **Write tests FIRST** in `test/test_queries.jl`:
   - Add `@testset "Filtering"` section after Todo CRUD tests
   - Test `filter_todos_by_status(db, status)` - create todos with different statuses, filter, verify
   - Test `filter_todos_by_project(db, project_id)` - filter by project
   - Test `filter_todos_by_category(db, category_id)` - filter by category
   - Test `filter_todos_by_date_range(db; start_date, due_date)` - filter by dates
   - Test `filter_todos(db; status, project_id, category_id, start_date, due_date)` - combined filters
   - Test empty results return `[]` not error

2. **Implement to pass tests** in `src/queries.jl`:
   - Follow same patterns as CRUD operations (parameterized queries, docstrings)
   - `filter_todos_by_status`: Simple WHERE clause on status
   - `filter_todos_by_project`: WHERE project_id = ?
   - `filter_todos_by_category`: WHERE category_id = ?
   - `filter_todos_by_date_range`: Build WHERE with date range logic
   - `filter_todos`: Build dynamic WHERE clause combining all provided filters with AND
   - All functions return `Vector{Todo}`

3. **Export functions** in `src/TodoList.jl`:
   ```julia
   export filter_todos_by_status, filter_todos_by_project, filter_todos_by_category
   export filter_todos_by_date_range, filter_todos
   ```

4. **Run tests** until all pass

5. **Update this plan** with ‚úÖ for Step 7

**THEN: Steps 10-11 - Utility Scripts**

After Step 7 complete:
- Use `/implement-step` for Step 10: Create `scripts/install.jl`
- Use `/implement-step` for Step 11: Create `scripts/demo.jl`
- Run `/verify-feature` again - should be PASS ‚úì
- Proceed to `/commit-push-pr`

### üîë Key Patterns to Follow

**1. CRUD Function Signatures:**
```julia
# CREATE - returns Int64 (new id)
create_todo(db::SQLite.DB, title::String; kwargs...)::Int64

# READ - returns Model or Nothing
get_todo(db::SQLite.DB, id::Int64)::Union{Todo, Nothing}

# LIST - returns Vector{Model}
list_todos(db::SQLite.DB)::Vector{Todo}

# UPDATE - returns Bool (true if found/updated)
update_todo!(db::SQLite.DB, id::Int64; kwargs...)::Bool

# DELETE - returns Bool (true if found/deleted)
delete_todo!(db::SQLite.DB, id::Int64)::Bool
```

**2. Missing to Nothing Conversion:**
```julia
ismissing(row[:field]) ? nothing : row[:field]
```

**3. Error Handling:**
```julia
try
    # DB operation
catch e
    if occursin("UNIQUE constraint failed", string(e))
        error("User-friendly message")
    else
        rethrow(e)
    end
end
```

**4. Update Pattern (dynamic fields):**
```julia
updates = String[]
params = []

if field !== nothing
    push!(updates, "field = ?")
    push!(params, field)
end

push!(params, id)  # For WHERE clause
query = "UPDATE table SET " * join(updates, ", ") * " WHERE id = ?"
```

**5. Timestamps:**
```julia
# For updates
Dates.format(now(), "yyyy-mm-dd HH:MM:SS")
```

### ‚ö†Ô∏è Important Details

**SQLite Row Access:**
- Use `row[:column_name]` (symbols), NOT `row["column_name"]` (strings)
- SQLite returns `Missing` for NULL, must convert to `nothing` for Julia structs

**Foreign Keys:**
- Always enabled in connection: `DBInterface.execute(db, "PRAGMA foreign_keys = ON")`
- ON DELETE SET NULL configured in schema

**Test Database:**
- Always use `:memory:` for tests
- Create fresh DB for each test: `db = connect_database(":memory:"); init_schema!(db)`

**Validation for Todo:**
- Status: Must be in `('pending', 'in_progress', 'completed', 'blocked')`
- Priority: Must be in `(1, 2, 3)`
- Dates: Format `YYYY-MM-DD`, validate with `Dates.Date(date_string)`
- Foreign keys: project_id and category_id must exist or be NULL

### üöÄ How to Resume

1. **Read updated governance:**
   - `CLAUDE.md` - Has new "Lessons Learned" about TDD workflow

2. **Check current branch:**
   ```bash
   git status  # Should be on feature/database-layer
   ```

3. **Review existing code patterns:**
   - Read `src/queries.jl` to see Project/Category CRUD patterns
   - Read `test/test_queries.jl` to see test patterns

4. **Run tests to verify clean state:**
   ```bash
   julia --project=. test/runtests.jl
   # Should show: Test Summary:  | Pass  Total
   #              TodoList Tests |   88     88
   ```

5. **Start Step 6:**
   - Open `test/test_queries.jl`
   - Add `@testset "Todo CRUD"` after Category CRUD tests
   - Write first test (e.g., "create todo with title only")
   - Run tests (will fail)
   - Implement in `src/queries.jl`
   - Run tests (should pass)
   - Repeat for each Todo CRUD function

### üìã Reference: Todo Struct Fields
```julia
struct Todo
    id::Union{Int64, Nothing}
    title::String
    description::Union{String, Nothing}
    status::String  # 'pending', 'in_progress', 'completed', 'blocked'
    priority::Int   # 1, 2, 3
    project_id::Union{Int64, Nothing}
    category_id::Union{Int64, Nothing}
    start_date::Union{String, Nothing}      # YYYY-MM-DD
    due_date::Union{String, Nothing}        # YYYY-MM-DD
    completed_at::Union{String, Nothing}    # Timestamp
    created_at::Union{String, Nothing}      # Timestamp
    updated_at::Union{String, Nothing}      # Timestamp
end
```

### üìù Context Management Note

This handoff follows new workflow: Clear context after completing feature units to maintain token efficiency and fresh focus. See CLAUDE.md "Lessons Learned" section for rationale.

## Steps

### Step 1: Update Project Dependencies

**Files to modify:**
- `Project.toml` - Add database dependencies

**Task Checklist:**
- [ ] Open Project.toml
- [ ] Add SQLite UUID to [deps] section: `SQLite = "0aa819cd-b072-5ff4-a722-6bc24af294d9"`
- [ ] Add DBInterface UUID to [deps] section: `DBInterface = "a10d1c49-ce27-4219-8d33-6db1a4562965"`
- [ ] Add Dates stdlib to [deps] section: `Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"`
- [ ] Add SQLite version constraint to [compat]: `SQLite = "1.6"`
- [ ] Add DBInterface version constraint to [compat]: `DBInterface = "2.5"`
- [ ] Save Project.toml
- [ ] Run: `julia --project=. -e 'using Pkg; Pkg.instantiate()'`
- [ ] Verify no errors during package installation
- [ ] Test import: `julia --project=. -e 'using SQLite'`
- [ ] Test import: `julia --project=. -e 'using DBInterface'`
- [ ] Test import: `julia --project=. -e 'using Dates'`
- [ ] Verify Manifest.toml was created/updated
- [ ] Check for dependency conflicts in output

**Changes:**
- Add SQLite.jl dependency (version ^1.6)
- Add DBInterface.jl dependency (version ^2.5)
- Dates stdlib is already available (no addition needed)
- Test stdlib is already available (no addition needed)

**Implementation:**
```toml
[deps]
SQLite = "0aa819cd-b072-5ff4-a722-6bc24af294d9"
DBInterface = "a10d1c49-ce27-4219-8d33-6db1a4562965"
Dates = "ade2ca70-3891-5945-98fb-dc099432e06a"

[compat]
julia = "1.12"
SQLite = "1.6"
DBInterface = "2.5"
```

**Tests:**
- Run `julia --project=. -e 'using Pkg; Pkg.instantiate()'` successfully
- Verify SQLite and DBInterface can be imported
- No dependency conflicts in Manifest.toml

**Success Criteria:**
- [ ] Project.toml has correct dependencies
- [ ] Pkg.instantiate() completes without errors
- [ ] Can import SQLite and DBInterface in Julia REPL

---

### Step 2: Create Data Models (models.jl)

**Files to create:**
- `src/models.jl` - Define Project, Category, Todo structs

**Task Checklist:**
- [ ] Create src/models.jl file
- [ ] Add module docstring explaining purpose of models
- [ ] Define Project struct with fields: id, name, description, color, created_at, updated_at
- [ ] Add docstring to Project struct documenting each field
- [ ] Verify Project field types: id (Union{Int64,Nothing}), name (String), others (Union{String,Nothing})
- [ ] Define Category struct with fields: id, name, color, created_at
- [ ] Add docstring to Category struct documenting each field
- [ ] Verify Category field types match schema
- [ ] Define Todo struct with all 12 fields (id, title, description, status, priority, project_id, category_id, start_date, due_date, completed_at, created_at, updated_at)
- [ ] Add docstring to Todo struct documenting each field
- [ ] Verify Todo field types: priority (Int), status (String), ids (Union{Int64,Nothing}), dates/strings (Union{String,Nothing})
- [ ] Add export statements if needed
- [ ] Save models.jl
- [ ] Test: `julia --project=. -e 'include("src/models.jl"); Project(nothing, "test", nothing, nothing, nothing, nothing)'`
- [ ] Test: Create Category instance with required fields
- [ ] Test: Create Todo instance with all fields
- [ ] Test: Create instances with Nothing values for nullable fields
- [ ] Verify no syntax errors

**Changes:**
Create Julia structs matching database schema:

```julia
# Project model
struct Project
    id::Union{Int64, Nothing}
    name::String
    description::Union{String, Nothing}
    color::Union{String, Nothing}
    created_at::Union{String, Nothing}
    updated_at::Union{String, Nothing}
end

# Category model
struct Category
    id::Union{Int64, Nothing}
    name::String
    color::Union{String, Nothing}
    created_at::Union{String, Nothing}
end

# Todo model
struct Todo
    id::Union{Int64, Nothing}
    title::String
    description::Union{String, Nothing}
    status::String
    priority::Int
    project_id::Union{Int64, Nothing}
    category_id::Union{Int64, Nothing}
    start_date::Union{String, Nothing}
    due_date::Union{String, Nothing}
    completed_at::Union{String, Nothing}
    created_at::Union{String, Nothing}
    updated_at::Union{String, Nothing}
end
```

**Additional Requirements:**
- Add docstrings for each struct explaining purpose and fields
- Follow Julia naming conventions (lowercase with underscores for functions)
- Type annotations match database schema (TEXT‚ÜíString, INTEGER‚ÜíInt64)
- Use Union{T, Nothing} for nullable fields

**Tests:**
- Unit test: Create instances of each struct
- Unit test: Verify field types are correct
- Unit test: Test Nothing values for nullable fields

**Success Criteria:**
- [ ] All three structs defined with correct fields and types
- [ ] Docstrings present for all structs
- [ ] Models can be instantiated in tests

---

### Step 3: Create Database Schema and Connection (database.jl)

**Files to create:**
- `src/database.jl` - Schema DDL, connection management, initialization

**Task Checklist:**
- [ ] Create src/database.jl file
- [ ] Add imports: `using SQLite`, `using DBInterface`
- [ ] Add module docstring
- [ ] Implement `get_database_path()` function with docstring
- [ ] Test path construction: uses `homedir()` and `joinpath()`
- [ ] Test directory creation: `mkpath()` creates ~/.todo-list/
- [ ] Implement `connect_database(db_path)` function with docstring
- [ ] Add `PRAGMA foreign_keys = ON` immediately after connection
- [ ] Test connection with :memory: database
- [ ] Test foreign keys enabled: query PRAGMA returns 1
- [ ] Implement `init_schema!(db)` function with docstring
- [ ] Add CREATE TABLE for projects (id, name UNIQUE NOT NULL, description, color, created_at, updated_at)
- [ ] Add CREATE TABLE for categories (id, name UNIQUE NOT NULL, color, created_at)
- [ ] Add CREATE TABLE for todos with all fields
- [ ] Add CHECK constraint for status: IN ('pending', 'in_progress', 'completed', 'blocked')
- [ ] Add CHECK constraint for priority: IN (1, 2, 3)
- [ ] Add FOREIGN KEY for project_id: REFERENCES projects(id) ON DELETE SET NULL
- [ ] Add FOREIGN KEY for category_id: REFERENCES categories(id) ON DELETE SET NULL
- [ ] Create index: idx_todos_status ON todos(status)
- [ ] Create index: idx_todos_project ON todos(project_id)
- [ ] Create index: idx_todos_category ON todos(category_id)
- [ ] Create index: idx_todos_due_date ON todos(due_date)
- [ ] Save database.jl
- [ ] Test: Create :memory: db and call init_schema!
- [ ] Test: Verify tables exist with PRAGMA table_list
- [ ] Test: Verify projects table structure with PRAGMA table_info(projects)
- [ ] Test: Verify categories table structure
- [ ] Test: Verify todos table structure with all constraints
- [ ] Test: Verify indexes exist

**Changes:**

1. **Database path helper:**
```julia
function get_database_path()::String
    # Cross-platform: ~/.todo-list/todos.db
    db_dir = joinpath(homedir(), ".todo-list")
    mkpath(db_dir)  # Create directory if it doesn't exist
    return joinpath(db_dir, "todos.db")
end
```

2. **Connection management:**
```julia
function connect_database(db_path::String = get_database_path())::SQLite.DB
    db = SQLite.DB(db_path)
    # CRITICAL: Enable foreign key constraints
    DBInterface.execute(db, "PRAGMA foreign_keys = ON")
    return db
end
```

3. **Schema initialization:**
```julia
function init_schema!(db::SQLite.DB)::Nothing
    # Create projects table
    DBInterface.execute(db, """
        CREATE TABLE IF NOT EXISTS projects (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL UNIQUE,
            description TEXT,
            color TEXT,
            created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
            updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
        )
    """)

    # Create categories table (similar)
    # Create todos table with foreign keys and constraints
    # Create indexes

    return nothing
end
```

**Full Schema (as specified in feature spec):**
- projects table: id, name (UNIQUE, NOT NULL), description, color, created_at, updated_at
- categories table: id, name (UNIQUE, NOT NULL), color, created_at
- todos table: id, title (NOT NULL), description, status (CHECK constraint), priority (CHECK constraint), project_id (FK), category_id (FK), dates, timestamps
- Indexes: idx_todos_status, idx_todos_project, idx_todos_category, idx_todos_due_date

**Tests:**
- Unit test: get_database_path() returns correct path with ~/.todo-list/
- Unit test: connect_database(:memory:) succeeds
- Unit test: PRAGMA foreign_keys returns ON (1)
- Unit test: init_schema! creates all tables
- Unit test: Verify table structure with PRAGMA table_info()
- Integration test: Create db, init schema, verify all constraints work

**Success Criteria:**
- [ ] Database connection works for both file and :memory:
- [ ] Foreign keys are enabled
- [ ] All tables created with correct structure
- [ ] Indexes created successfully
- [ ] Cross-platform path handling works

---

### Step 4: Implement Project CRUD Operations (queries.jl part 1)

**Files to create:**
- `src/queries.jl` - Start with Project operations

**Task Checklist:**
- [ ] Create src/queries.jl file
- [ ] Add imports: `using SQLite`, `using DBInterface`, `using Dates`
- [ ] Include models: `include("models.jl")`
- [ ] Add module docstring
- [ ] Implement `create_project(db, name; description, color)` with docstring
- [ ] Use parameterized INSERT query with DBInterface.execute
- [ ] Handle UNIQUE constraint violation with try-catch
- [ ] Return inserted row id using `DBInterface.lastrowid`
- [ ] Test create_project with minimal fields (name only)
- [ ] Test create_project with all fields
- [ ] Test duplicate name throws user-friendly error
- [ ] Implement `get_project(db, id)` with docstring
- [ ] Use parameterized SELECT query
- [ ] Return Project struct or nothing
- [ ] Use string keys: row["column"]
- [ ] Test get_project with valid id
- [ ] Test get_project with non-existent id returns nothing
- [ ] Implement `list_projects(db)` with docstring
- [ ] Return Vector{Project}
- [ ] Test with empty database returns []
- [ ] Test with multiple projects
- [ ] Implement `update_project!(db, id; name, description, color)` with docstring
- [ ] Build dynamic UPDATE query for provided fields only
- [ ] Set updated_at = current timestamp explicitly
- [ ] Use parameterized query
- [ ] Return true if updated, false if not found
- [ ] Test update single field
- [ ] Test update multiple fields
- [ ] Test updated_at timestamp changes
- [ ] Implement `delete_project!(db, id)` with docstring
- [ ] Use parameterized DELETE query
- [ ] Return true if deleted, false if not found
- [ ] Test delete existing project
- [ ] Test delete non-existent project
- [ ] Test foreign key ON DELETE SET NULL (create todo with project, delete project, verify todo.project_id is null)
- [ ] Add docstrings to all functions
- [ ] Save queries.jl

**Changes:**

Implement full CRUD for projects:

```julia
# CREATE
function create_project(db::SQLite.DB, name::String;
                       description::Union{String,Nothing}=nothing,
                       color::Union{String,Nothing}=nothing)::Int64
    # Validate inputs
    # Use parameterized query (SQL injection prevention)
    # Handle unique constraint violation with user-friendly error
    # Return inserted id
end

# READ
function get_project(db::SQLite.DB, id::Int64)::Union{Project, Nothing}
    # Query by id, return Project struct or nothing
end

function list_projects(db::SQLite.DB)::Vector{Project}
    # Return all projects
end

# UPDATE
function update_project!(db::SQLite.DB, id::Int64;
                        name::Union{String,Nothing}=nothing,
                        description::Union{String,Nothing}=nothing,
                        color::Union{String,Nothing}=nothing)::Bool
    # Update specified fields
    # Update updated_at timestamp explicitly
    # Return true if successful
end

# DELETE
function delete_project!(db::SQLite.DB, id::Int64)::Bool
    # Delete project
    # Foreign key ON DELETE SET NULL handles todos
    # Return true if deleted
end
```

**Key Requirements:**
- ALL queries use parameterized statements (DBInterface.execute with params)
- String keys for row access: row["column"] not row[:column]
- Proper error handling with user-friendly messages
- Type annotations on all function signatures
- Docstrings for all public functions
- Timestamps: updated_at set explicitly in Julia code (not DB trigger)

**Tests:**
- test_create_project: Create and verify
- test_create_duplicate_project: Expect error
- test_get_project: Retrieve by id
- test_get_nonexistent_project: Returns nothing
- test_list_projects: Empty and populated
- test_update_project: Modify fields
- test_delete_project: Remove and verify

**Success Criteria:**
- [ ] All Project CRUD operations work correctly
- [ ] Parameterized queries used throughout
- [ ] Unique constraint violations handled gracefully
- [ ] All tests pass

---

### Step 5: Implement Category CRUD Operations (queries.jl part 2)

**Files to modify:**
- `src/queries.jl` - Add Category operations

**Task Checklist:**
- [ ] Implement `create_category(db, name; color)` with docstring
- [ ] Use parameterized INSERT query
- [ ] Handle UNIQUE constraint violation
- [ ] Return inserted id
- [ ] Test create with name only
- [ ] Test create with all fields
- [ ] Test duplicate name error
- [ ] Implement `get_category(db, id)` with docstring
- [ ] Use parameterized SELECT query
- [ ] Return Category struct or nothing
- [ ] Use string keys for row access
- [ ] Test get with valid id
- [ ] Test get with non-existent id
- [ ] Implement `list_categories(db)` with docstring
- [ ] Return Vector{Category}
- [ ] Test with empty database
- [ ] Test with multiple categories
- [ ] Implement `update_category!(db, id; name, color)` with docstring
- [ ] Build dynamic UPDATE for provided fields
- [ ] Use parameterized query
- [ ] Return true/false
- [ ] Test update name
- [ ] Test update color
- [ ] Implement `delete_category!(db, id)` with docstring
- [ ] Use parameterized DELETE
- [ ] Return true/false
- [ ] Test delete existing category
- [ ] Test delete with todos using category (verify ON DELETE SET NULL)
- [ ] Add docstrings to all functions
- [ ] Save queries.jl

**Changes:**

Implement full CRUD for categories (similar structure to projects):

```julia
function create_category(db::SQLite.DB, name::String;
                        color::Union{String,Nothing}=nothing)::Int64

function get_category(db::SQLite.DB, id::Int64)::Union{Category, Nothing}

function list_categories(db::SQLite.DB)::Vector{Category}

function update_category!(db::SQLite.DB, id::Int64;
                         name::Union{String,Nothing}=nothing,
                         color::Union{String,Nothing}=nothing)::Bool

function delete_category!(db::SQLite.DB, id::Int64)::Bool
```

**Key Requirements:**
- Same patterns as Project CRUD
- Handle UNIQUE constraint on name
- Foreign key handling for todos

**Tests:**
- test_create_category
- test_duplicate_category_name
- test_get_category
- test_list_categories
- test_update_category
- test_delete_category

**Success Criteria:**
- [ ] All Category CRUD operations work
- [ ] Tests pass
- [ ] Consistent with Project patterns

---

### Step 6: Implement Todo CRUD Operations (queries.jl part 3)

**Files to modify:**
- `src/queries.jl` - Add Todo operations

**Task Checklist:**
- [ ] Implement `create_todo(db, title; description, status, priority, project_id, category_id, start_date, due_date)` with docstring
- [ ] Validate status is in ('pending', 'in_progress', 'completed', 'blocked')
- [ ] Validate priority is in (1, 2, 3)
- [ ] Validate date format YYYY-MM-DD if provided (use try-catch with Date())
- [ ] Use parameterized INSERT query
- [ ] Handle foreign key violations with user-friendly error
- [ ] Return inserted id
- [ ] Test create with title only
- [ ] Test create with all fields
- [ ] Test create with valid project_id
- [ ] Test create with valid category_id
- [ ] Test create with invalid project_id (expect error)
- [ ] Test create with invalid category_id (expect error)
- [ ] Test create with invalid status (expect error)
- [ ] Test create with invalid priority (expect error)
- [ ] Test create with invalid date format (expect error)
- [ ] Implement `get_todo(db, id)` with docstring
- [ ] Use parameterized SELECT
- [ ] Return Todo struct or nothing
- [ ] Use string keys for row access
- [ ] Test get with valid id
- [ ] Test get with non-existent id
- [ ] Implement `list_todos(db)` with docstring
- [ ] Return Vector{Todo}
- [ ] Test with empty database
- [ ] Test with multiple todos
- [ ] Implement `update_todo!(db, id; all optional fields)` with docstring
- [ ] Build dynamic UPDATE for provided fields
- [ ] Validate status, priority, dates if provided
- [ ] Set updated_at explicitly
- [ ] Use parameterized query
- [ ] Return true/false
- [ ] Test update single field
- [ ] Test update multiple fields
- [ ] Test validation on update
- [ ] Implement `complete_todo!(db, id)` with docstring
- [ ] Set status = 'completed'
- [ ] Set completed_at = current timestamp
- [ ] Set updated_at = current timestamp
- [ ] Return true/false
- [ ] Test complete_todo sets both timestamps
- [ ] Test complete_todo changes status
- [ ] Implement `delete_todo!(db, id)` with docstring
- [ ] Use parameterized DELETE
- [ ] Return true/false
- [ ] Test delete existing todo
- [ ] Test delete non-existent todo
- [ ] Add docstrings to all functions
- [ ] Save queries.jl

**Changes:**

Implement full CRUD for todos:

```julia
function create_todo(db::SQLite.DB, title::String;
                    description::Union{String,Nothing}=nothing,
                    status::String="pending",
                    priority::Int=2,
                    project_id::Union{Int64,Nothing}=nothing,
                    category_id::Union{Int64,Nothing}=nothing,
                    start_date::Union{String,Nothing}=nothing,
                    due_date::Union{String,Nothing}=nothing)::Int64
    # Validate status in ('pending', 'in_progress', 'completed', 'blocked')
    # Validate priority in (1, 2, 3)
    # Validate date format YYYY-MM-DD if provided
    # Handle foreign key violations with clear errors
end

function get_todo(db::SQLite.DB, id::Int64)::Union{Todo, Nothing}

function list_todos(db::SQLite.DB)::Vector{Todo}

function update_todo!(db::SQLite.DB, id::Int64;
                     title::Union{String,Nothing}=nothing,
                     status::Union{String,Nothing}=nothing,
                     # ... all other fields ...)::Bool
    # Update updated_at timestamp
    # Validate changed fields
end

function complete_todo!(db::SQLite.DB, id::Int64)::Bool
    # Convenience function: set status='completed', completed_at=now()
end

function delete_todo!(db::SQLite.DB, id::Int64)::Bool
```

**Validation Requirements:**
- Status: Must be one of: pending, in_progress, completed, blocked
- Priority: Must be 1, 2, or 3
- Dates: Must match YYYY-MM-DD format if provided
- Foreign keys: project_id and category_id must exist or be NULL

**Tests:**
- test_create_todo: Basic todo
- test_create_todo_with_project: With valid project_id
- test_create_todo_invalid_project: With invalid project_id (expect error)
- test_create_todo_invalid_status: Expect error
- test_create_todo_invalid_priority: Expect error
- test_create_todo_invalid_date_format: Expect error
- test_get_todo
- test_list_todos
- test_update_todo
- test_complete_todo: Verify status and completed_at
- test_delete_todo

**Success Criteria:**
- [ ] All Todo CRUD operations work
- [ ] All validations enforce correctly
- [ ] Foreign key violations caught with clear errors
- [ ] Complete helper function works
- [ ] All tests pass

---

### Step 7: Implement Query Filtering Functions (queries.jl part 4)

**Files to modify:**
- `src/queries.jl` - Add filtering functions

**Task Checklist:**
- [ ] Implement `filter_todos_by_status(db, status)` with docstring
- [ ] Use parameterized SELECT with WHERE status = ?
- [ ] Return Vector{Todo}
- [ ] Test filter for 'pending' status
- [ ] Test filter for each status value
- [ ] Test with no matches returns []
- [ ] Implement `filter_todos_by_project(db, project_id)` with docstring
- [ ] Use parameterized SELECT with WHERE project_id = ?
- [ ] Return Vector{Todo}
- [ ] Test filter with valid project_id
- [ ] Test with no matches returns []
- [ ] Implement `filter_todos_by_category(db, category_id)` with docstring
- [ ] Use parameterized SELECT with WHERE category_id = ?
- [ ] Return Vector{Todo}
- [ ] Test filter with valid category_id
- [ ] Test with no matches returns []
- [ ] Implement `filter_todos_by_date_range(db; start_date, due_date)` with docstring
- [ ] Build WHERE clause for date range
- [ ] Handle NULL dates appropriately
- [ ] Use parameterized query
- [ ] Return Vector{Todo}
- [ ] Test filter by start_date only
- [ ] Test filter by due_date only
- [ ] Test filter by both dates
- [ ] Implement `filter_todos(db; status, project_id, category_id, start_date, due_date)` with docstring
- [ ] Build dynamic WHERE clause for provided parameters
- [ ] Combine multiple conditions with AND
- [ ] Use parameterized query
- [ ] Return Vector{Todo}
- [ ] Test with single filter (status)
- [ ] Test with two filters (status + project)
- [ ] Test with three filters (status + project + category)
- [ ] Test with all filters
- [ ] Test with no filters returns all todos
- [ ] Test with no matches returns []
- [ ] Add docstrings to all functions
- [ ] Save queries.jl

**Changes:**

Add filtering capabilities:

```julia
function filter_todos_by_status(db::SQLite.DB, status::String)::Vector{Todo}
    # Return todos matching status
end

function filter_todos_by_project(db::SQLite.DB, project_id::Int64)::Vector{Todo}
    # Return todos in project (including NULL check)
end

function filter_todos_by_category(db::SQLite.DB, category_id::Int64)::Vector{Todo}
    # Return todos in category
end

function filter_todos_by_date_range(db::SQLite.DB,
                                   start_date::Union{String,Nothing}=nothing,
                                   due_date::Union{String,Nothing}=nothing)::Vector{Todo}
    # Return todos within date range
    # Handle NULL dates appropriately
end

function filter_todos(db::SQLite.DB;
                     status::Union{String,Nothing}=nothing,
                     project_id::Union{Int64,Nothing}=nothing,
                     category_id::Union{Int64,Nothing}=nothing,
                     start_date::Union{String,Nothing}=nothing,
                     due_date::Union{String,Nothing}=nothing)::Vector{Todo}
    # Combined filter function
    # Build dynamic WHERE clause based on provided parameters
end
```

**Tests:**
- test_filter_by_status: Create todos with different statuses, filter
- test_filter_by_project: Filter by project
- test_filter_by_category: Filter by category
- test_filter_by_date_range: Filter by dates
- test_combined_filters: Use multiple filters together
- test_empty_results: Verify empty array returned (not error)

**Success Criteria:**
- [ ] All filter functions work correctly
- [ ] Combined filter handles multiple criteria
- [ ] Empty results return [] not error
- [ ] NULL handling works correctly
- [ ] All tests pass

---

### Step 8: Create Main Module Entry Point (TodoList.jl)

**Files to create:**
- `src/TodoList.jl` - Main module definition

**Task Checklist:**
- [ ] Create src/TodoList.jl file
- [ ] Add module declaration: `module TodoList`
- [ ] Add module docstring explaining purpose
- [ ] Import SQLite: `using SQLite`
- [ ] Import DBInterface: `using DBInterface`
- [ ] Import Dates: `using Dates`
- [ ] Include models.jl: `include("models.jl")`
- [ ] Include database.jl: `include("database.jl")`
- [ ] Include queries.jl: `include("queries.jl")`
- [ ] Export data models: Project, Category, Todo
- [ ] Export database functions: connect_database, init_schema!, get_database_path
- [ ] Export project CRUD: create_project, get_project, list_projects, update_project!, delete_project!
- [ ] Export category CRUD: create_category, get_category, list_categories, update_category!, delete_category!
- [ ] Export todo CRUD: create_todo, get_todo, list_todos, update_todo!, complete_todo!, delete_todo!
- [ ] Export filter functions: filter_todos_by_status, filter_todos_by_project, filter_todos_by_category, filter_todos_by_date_range, filter_todos
- [ ] Add end module statement
- [ ] Save TodoList.jl
- [ ] Test: `julia --project=. -e 'using TodoList'` succeeds
- [ ] Test: Verify Project struct accessible
- [ ] Test: Verify create_project accessible
- [ ] Test: Verify all exports work

**Changes:**

```julia
module TodoList

# Import dependencies
using SQLite
using DBInterface
using Dates

# Include source files
include("models.jl")
include("database.jl")
include("queries.jl")

# Export public API
export Project, Category, Todo
export connect_database, init_schema!, get_database_path
export create_project, get_project, list_projects, update_project!, delete_project!
export create_category, get_category, list_categories, update_category!, delete_category!
export create_todo, get_todo, list_todos, update_todo!, complete_todo!, delete_todo!
export filter_todos_by_status, filter_todos_by_project, filter_todos_by_category
export filter_todos_by_date_range, filter_todos

end # module
```

**Tests:**
- test_module_loads: using TodoList succeeds
- test_exports_available: Verify all exports accessible

**Success Criteria:**
- [ ] Module loads without errors
- [ ] All exports accessible
- [ ] No naming conflicts

---

### Step 9: Create Test Suite Structure (test/)

**Files to create:**
- `test/runtests.jl` - Test entry point
- `test/test_database.jl` - Database schema tests
- `test/test_queries.jl` - CRUD operation tests

**Task Checklist:**
- [ ] Create test/ directory if not exists
- [ ] Create test/runtests.jl file
- [ ] Add imports: using Test, using TodoList, using SQLite, using DBInterface
- [ ] Add @testset "TodoList Tests" wrapper
- [ ] Include test_database.jl
- [ ] Include test_queries.jl
- [ ] Create test/test_database.jl file
- [ ] Add @testset "Database Tests" wrapper
- [ ] Add @testset "Connection" with tests for connect_database and foreign keys
- [ ] Add @testset "Schema Creation" with tests for init_schema!
- [ ] Add @testset "Constraints" with tests for UNIQUE, CHECK, and FK constraints
- [ ] Write test: database_path_construction (verify ~/.todo-list/todos.db format)
- [ ] Write test: connect_memory_database (verify :memory: works)
- [ ] Write test: foreign_keys_enabled (verify PRAGMA returns 1)
- [ ] Write test: init_schema_creates_tables (verify 3 tables exist)
- [ ] Write test: projects_table_structure (verify columns with PRAGMA table_info)
- [ ] Write test: categories_table_structure
- [ ] Write test: todos_table_structure
- [ ] Write test: indexes_created (verify 4 indexes exist)
- [ ] Write test: unique_constraint_project_name (try duplicate, expect error)
- [ ] Write test: check_constraint_status (try invalid status, expect error)
- [ ] Write test: check_constraint_priority (try invalid priority, expect error)
- [ ] Write test: foreign_key_constraint (try invalid project_id, expect error)
- [ ] Create test/test_queries.jl file
- [ ] Add @testset "Query Tests" wrapper
- [ ] Add @testset "Project CRUD" with all project tests from Step 4
- [ ] Add @testset "Category CRUD" with all category tests from Step 5
- [ ] Add @testset "Todo CRUD" with all todo tests from Step 6
- [ ] Add @testset "Filtering" with all filter tests from Step 7
- [ ] Add @testset "Integration Tests" with workflow and cascading delete tests
- [ ] Write all project CRUD tests (create, get, list, update, delete, duplicates)
- [ ] Write all category CRUD tests (create, get, list, update, delete, duplicates)
- [ ] Write all todo CRUD tests (create with validations, get, list, update, complete, delete)
- [ ] Write all filter tests (by status, project, category, date range, combined)
- [ ] Write integration test: complete_workflow (create project, category, todo; update; delete)
- [ ] Write integration test: cascading_deletes (verify ON DELETE SET NULL)
- [ ] Ensure all tests use :memory: databases
- [ ] Ensure each test creates fresh database
- [ ] Save all test files
- [ ] Run: julia --project=. test/runtests.jl
- [ ] Verify all tests pass

**Changes:**

**test/runtests.jl:**
```julia
using Test
using TodoList
using SQLite
using DBInterface

@testset "TodoList Tests" begin
    include("test_database.jl")
    include("test_queries.jl")
end
```

**test/test_database.jl:**
```julia
@testset "Database Tests" begin
    @testset "Connection" begin
        # Test :memory: connection
        # Test foreign keys enabled
    end

    @testset "Schema Creation" begin
        # Test init_schema! creates tables
        # Verify table structure
    end

    @testset "Constraints" begin
        # Test UNIQUE constraints
        # Test CHECK constraints
        # Test foreign keys
    end
end
```

**test/test_queries.jl:**
```julia
@testset "Query Tests" begin
    @testset "Project CRUD" begin
        # All project tests from Step 4
    end

    @testset "Category CRUD" begin
        # All category tests from Step 5
    end

    @testset "Todo CRUD" begin
        # All todo tests from Step 6
    end

    @testset "Filtering" begin
        # All filter tests from Step 7
    end

    @testset "Integration Tests" begin
        # test_complete_workflow
        # test_cascading_deletes
    end
end
```

**Test Best Practices:**
- Use :memory: databases for all tests (no file I/O)
- Each test gets fresh database instance
- Test edge cases and error conditions
- Verify error messages are user-friendly
- Test both empty and populated databases

**Success Criteria:**
- [ ] Test structure follows Julia conventions
- [ ] All tests use :memory: databases
- [ ] Tests are organized by functionality
- [ ] All tests pass

---

### Step 10: Create Installation Script (scripts/install.jl)

**Files to create:**
- `scripts/install.jl` - First-time database setup

**Task Checklist:**
- [ ] Create scripts/install.jl file (if directory doesn't exist, create it)
- [ ] Add shebang line: `#!/usr/bin/env julia`
- [ ] Add script header comment explaining purpose
- [ ] Add `using Pkg; Pkg.activate(".")`
- [ ] Add `using TodoList`
- [ ] Define main() function
- [ ] Print installation header with separator line
- [ ] Call get_database_path() and store result
- [ ] Print database path to user
- [ ] Check if database file already exists with isfile()
- [ ] If exists, prompt user: "Database already exists. Overwrite? (y/N): "
- [ ] Read user response with readline()
- [ ] If not 'y', print "Installation cancelled." and return
- [ ] If 'y', delete existing database with rm(db_path)
- [ ] Print "Creating database and schema..."
- [ ] Call connect_database(db_path)
- [ ] Call init_schema!(db)
- [ ] Print success messages
- [ ] Call main() at end of script
- [ ] Make script executable: chmod +x scripts/install.jl (on Unix systems)
- [ ] Save scripts/install.jl
- [ ] Test: Run `julia --project=. scripts/install.jl`
- [ ] Verify database created at ~/.todo-list/todos.db
- [ ] Test: Run script again and test overwrite prompt (answer N)
- [ ] Test: Run script again and test overwrite prompt (answer y)
- [ ] Manual: Open database in SQLite browser and verify tables

**Changes:**

```julia
#!/usr/bin/env julia

# Database installation script
# Creates ~/.todo-list/todos.db and initializes schema

using Pkg
Pkg.activate(".")

using TodoList

function main()
    println("TodoList Database Installation")
    println("=" ^ 50)

    db_path = get_database_path()
    println("\nDatabase path: $db_path")

    if isfile(db_path)
        print("Database already exists. Overwrite? (y/N): ")
        response = readline()
        if lowercase(strip(response)) != "y"
            println("Installation cancelled.")
            return
        end
        rm(db_path)
    end

    println("\nCreating database and schema...")
    db = connect_database(db_path)
    init_schema!(db)

    println("‚úì Database created successfully!")
    println("‚úì Schema initialized!")
    println("\nYou can now use the TodoList application.")
end

main()
```

**Tests (Manual):**
- [ ] Run script and verify database created at ~/.todo-list/todos.db
- [ ] Open database in SQLite browser, verify tables exist
- [ ] Run script again, test overwrite prompt
- [ ] Verify schema matches specification

**Success Criteria:**
- [ ] Script creates database at correct location
- [ ] Schema initialized correctly
- [ ] Overwrite protection works
- [ ] User-friendly output messages

---

### Step 11: Create Demo Data Script (scripts/demo.jl)

**Files to create:**
- `scripts/demo.jl` - Generate sample data

**Task Checklist:**
- [ ] Create scripts/demo.jl file
- [ ] Add shebang line: `#!/usr/bin/env julia`
- [ ] Add script header comment
- [ ] Add `using Pkg; Pkg.activate(".")`
- [ ] Add `using TodoList`
- [ ] Define main() function
- [ ] Print demo data generator header
- [ ] Connect to database: `db = connect_database()`
- [ ] Print "Creating projects..."
- [ ] Create project 1: "Home Renovation" with description and color
- [ ] Create project 2: "Work Tasks" with description and color
- [ ] Store returned project IDs
- [ ] Print "‚úì Created 2 projects"
- [ ] Print "Creating categories..."
- [ ] Create category 1: "Urgent" with color
- [ ] Create category 2: "Planning" with color
- [ ] Store returned category IDs
- [ ] Print "‚úì Created 2 categories"
- [ ] Print "Creating todos..."
- [ ] Create todo 1: "Design new kitchen layout" with project, category, priority, status, due_date
- [ ] Create todo 2: "Get contractor quotes" with project, category, priority, due_date
- [ ] Create todo 3: "Finish Q1 report" with project, category, priority, status, due_date
- [ ] Create 7 more todos with variety of statuses, priorities, and relationships
- [ ] Print "‚úì Created 10 todos"
- [ ] Print summary header
- [ ] Print project count: `length(list_projects(db))`
- [ ] Print category count: `length(list_categories(db))`
- [ ] Print todo count: `length(list_todos(db))`
- [ ] Call main() at end of script
- [ ] Make script executable (chmod +x on Unix)
- [ ] Save scripts/demo.jl
- [ ] Test: Run `julia --project=. scripts/demo.jl`
- [ ] Verify output shows 2 projects, 2 categories, 10 todos
- [ ] Manual: Query database to verify data exists and is correct

**Changes:**

```julia
#!/usr/bin/env julia

# Demo data generation script
# Populates database with sample projects, categories, and todos

using Pkg
Pkg.activate(".")

using TodoList

function main()
    println("TodoList Demo Data Generator")
    println("=" ^ 50)

    db = connect_database()

    # Create sample projects
    println("\nCreating projects...")
    proj1_id = create_project(db, "Home Renovation",
                              description="Kitchen and bathroom updates",
                              color="#FF6B6B")
    proj2_id = create_project(db, "Work Tasks",
                              description="Q1 deliverables",
                              color="#4ECDC4")
    println("‚úì Created 2 projects")

    # Create sample categories
    println("\nCreating categories...")
    cat1_id = create_category(db, "Urgent", color="#E74C3C")
    cat2_id = create_category(db, "Planning", color="#3498DB")
    println("‚úì Created 2 categories")

    # Create sample todos
    println("\nCreating todos...")
    create_todo(db, "Design new kitchen layout",
               project_id=proj1_id,
               category_id=cat2_id,
               priority=1,
               status="in_progress",
               due_date="2026-02-15")

    create_todo(db, "Get contractor quotes",
               project_id=proj1_id,
               category_id=cat1_id,
               priority=1,
               due_date="2026-01-30")

    create_todo(db, "Finish Q1 report",
               project_id=proj2_id,
               category_id=cat1_id,
               priority=1,
               status="pending",
               due_date="2026-01-31")

    # More todos...
    println("‚úì Created 10 todos")

    println("\n‚úì Demo data loaded successfully!")
    println("\nSummary:")
    println("  Projects: $(length(list_projects(db)))")
    println("  Categories: $(length(list_categories(db)))")
    println("  Todos: $(length(list_todos(db)))")
end

main()
```

**Tests (Manual):**
- [ ] Run demo.jl and verify data appears in database
- [ ] Verify foreign key relationships correct
- [ ] Query data and verify it matches expectations

**Success Criteria:**
- [ ] Demo script populates database with sample data
- [ ] All foreign keys valid
- [ ] Data visible in database

---

### Step 12: Update Documentation (README.md)

**Files to modify:**
- `README.md` - Add database documentation

**Task Checklist:**
- [ ] Open README.md
- [ ] Find or create "Database Schema" section
- [ ] Document projects table with all fields and descriptions
- [ ] Document categories table with all fields and descriptions
- [ ] Document todos table with all fields and descriptions
- [ ] Document status values: pending, in_progress, completed, blocked
- [ ] Document priority values: 1 (high), 2 (medium), 3 (low)
- [ ] Document foreign key relationships
- [ ] Find or create "Installation" section
- [ ] Add step: Clone repository
- [ ] Add step: Install dependencies with Pkg.instantiate()
- [ ] Add step: Initialize database with scripts/install.jl
- [ ] Add step: (Optional) Load demo data with scripts/demo.jl
- [ ] Find or create "Running Tests" section
- [ ] Add command: `julia --project=. test/runtests.jl`
- [ ] Add command: `./scripts/docker-test` (Docker alternative)
- [ ] Update "Quick Start" section with database-specific steps
- [ ] Add example of creating a todo programmatically
- [ ] Update "Development Workflow" if needed
- [ ] Verify all code examples are accurate
- [ ] Save README.md
- [ ] Test: Follow README instructions from scratch to verify accuracy
- [ ] Proofread for typos and clarity

**Changes:**

Add sections:

1. **Database Schema** - Document all tables with descriptions
2. **Installation** - Update setup instructions
3. **Development Workflow** - Add database-specific commands

**Content to Add:**

```markdown
## Database Schema

### projects
- `id`: Primary key (auto-increment)
- `name`: Project name (unique, required)
- `description`: Project description (optional)
- `color`: Hex color for visualization (optional)
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

### categories
- `id`: Primary key (auto-increment)
- `name`: Category name (unique, required)
- `color`: Hex color for visualization (optional)
- `created_at`: Creation timestamp

### todos
- `id`: Primary key (auto-increment)
- `title`: Todo title (required)
- `description`: Detailed description (optional)
- `status`: One of: pending, in_progress, completed, blocked
- `priority`: 1 (high), 2 (medium), 3 (low)
- `project_id`: Foreign key to projects (optional)
- `category_id`: Foreign key to categories (optional)
- `start_date`: Start date in YYYY-MM-DD format (optional)
- `due_date`: Due date in YYYY-MM-DD format (optional)
- `completed_at`: Completion timestamp (optional)
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

## Getting Started

### Installation

1. Clone the repository
2. Install dependencies: `julia --project=. -e 'using Pkg; Pkg.instantiate()'`
3. Initialize database: `julia --project=. scripts/install.jl`
4. (Optional) Load demo data: `julia --project=. scripts/demo.jl`

### Running Tests

```bash
julia --project=. test/runtests.jl
```

Or in Docker:
```bash
./scripts/docker-test
```
```

**Success Criteria:**
- [ ] README has complete database schema documentation
- [ ] Installation instructions clear and accurate
- [ ] All examples work as documented

---

### Step 13: Run Full Test Suite and Verify

**Files to test:**
- All implemented files

**Task Checklist:**
- [ ] Run automated test suite: `julia --project=. test/runtests.jl`
- [ ] Verify all database tests pass
- [ ] Verify all project CRUD tests pass
- [ ] Verify all category CRUD tests pass
- [ ] Verify all todo CRUD tests pass
- [ ] Verify all filter tests pass
- [ ] Verify all integration tests pass
- [ ] Check for any test warnings or deprecations
- [ ] Run tests in Docker: `./scripts/docker-test`
- [ ] Verify Docker tests pass
- [ ] Manual test: Run `julia --project=. scripts/install.jl`
- [ ] Manual test: Verify ~/.todo-list/todos.db created
- [ ] Manual test: Run `julia --project=. scripts/demo.jl`
- [ ] Manual test: Open database in SQLite browser (e.g., DB Browser for SQLite)
- [ ] Manual test: Verify projects table has 2 rows
- [ ] Manual test: Verify categories table has 2 rows
- [ ] Manual test: Verify todos table has 10 rows
- [ ] Manual test: Verify foreign key relationships are correct
- [ ] Manual test: Verify indexes exist (check schema in SQLite browser)
- [ ] Run `git status` and verify no .db files staged
- [ ] Verify .gitignore is working (no database files tracked)
- [ ] Review all code for TODOs or FIXMEs
- [ ] Verify all functions have docstrings
- [ ] Check that parameterized queries used throughout
- [ ] Verify error messages are user-friendly
- [ ] Create summary of what was implemented
- [ ] Document any issues or gotchas discovered
- [ ] Prepare for PR creation (but don't create yet)

**Changes:**
- Run complete test suite
- Verify all tests pass
- Check test coverage
- Run manual tests

**Test Commands:**
```bash
# In Docker (recommended)
./scripts/docker-test

# Or locally
julia --project=. test/runtests.jl
```

**Manual Verification:**
1. Install database: `julia --project=. scripts/install.jl`
2. Load demo data: `julia --project=. scripts/demo.jl`
3. Open database in SQLite browser and inspect
4. Run tests in Docker: `./scripts/docker-test`

**Success Criteria:**
- [ ] All automated tests pass
- [ ] Manual tests complete successfully
- [ ] Database created at correct location
- [ ] Demo data loads correctly
- [ ] No database files committed to git

---

## Files

### New Files
- `src/TodoList.jl` - Main module entry point
- `src/models.jl` - Project, Category, Todo structs
- `src/database.jl` - Schema, connections, initialization
- `src/queries.jl` - CRUD operations and filtering
- `test/runtests.jl` - Test suite entry point
- `test/test_database.jl` - Database and schema tests
- `test/test_queries.jl` - CRUD and filter tests
- `scripts/install.jl` - Database initialization script
- `scripts/demo.jl` - Demo data generation script

### Modified Files
- `Project.toml` - Add SQLite.jl and DBInterface.jl dependencies
- `README.md` - Add database schema documentation and setup instructions
- `.gitignore` - Already configured for database files (verify)

## Risks

### Risk 1: Stashed Work May Have Issues
**Mitigation:** Review stashed code carefully. Use tests to validate correctness. If issues found, reimplement following this plan.

### Risk 2: Cross-Platform Path Handling
**Mitigation:** Use Julia's `homedir()` and `joinpath()` consistently. Test on Windows. Docker provides Linux environment for testing.

### Risk 3: Foreign Key Enforcement
**Mitigation:** Always execute `PRAGMA foreign_keys = ON` immediately after connection. Verify in tests.

### Risk 4: Date Format Validation
**Mitigation:** Validate dates explicitly in Julia code before database insertion. Use try-catch for Date parsing.

### Risk 5: SQL Injection
**Mitigation:** Use parameterized queries exclusively via DBInterface. Never concatenate strings into SQL.

### Risk 6: Test Database Cleanup
**Mitigation:** Use `:memory:` databases for all tests. Ensure no file-based test databases created.

## Acceptance Criteria

### Functionality
- [ ] Database schema matches CLAUDE.md specification exactly
- [ ] All three tables (projects, categories, todos) created correctly
- [ ] Foreign keys enforced (PRAGMA foreign_keys = ON)
- [ ] CHECK constraints work (status, priority)
- [ ] UNIQUE constraints work (project names, category names)
- [ ] Indexes created on todos table

### Data Models
- [ ] Project, Category, Todo structs defined
- [ ] Field types match database schema
- [ ] Nullable fields use Union{T, Nothing}
- [ ] All structs have docstrings

### CRUD Operations
- [ ] Projects: create, read, list, update, delete work correctly
- [ ] Categories: create, read, list, update, delete work correctly
- [ ] Todos: create, read, list, update, complete, delete work correctly
- [ ] All operations use parameterized queries
- [ ] Error messages are user-friendly

### Filtering
- [ ] Filter by status works
- [ ] Filter by project works
- [ ] Filter by category works
- [ ] Filter by date range works
- [ ] Combined filters work
- [ ] Empty results return [] not error

### Testing
- [ ] All unit tests pass
- [ ] All integration tests pass
- [ ] Tests use :memory: databases only
- [ ] Edge cases tested (nulls, constraints, empty database)
- [ ] Error conditions tested

### Scripts
- [ ] install.jl creates database at ~/.todo-list/todos.db
- [ ] install.jl initializes schema correctly
- [ ] demo.jl populates sample data
- [ ] Both scripts have user-friendly output

### Documentation
- [ ] README.md has complete database schema section
- [ ] Installation instructions are clear
- [ ] All public functions have docstrings
- [ ] Comments explain complex logic in database.jl

### Git Hygiene
- [ ] No database files committed (.db, .db-shm, .db-wal)
- [ ] .gitignore configured correctly (already done)
- [ ] All work on feature/database-layer branch
- [ ] Tests pass before creating PR

## Testing Strategy

### Unit Tests (test/test_database.jl)
- Database path generation (cross-platform)
- Connection creation (:memory: and file)
- Foreign keys enabled check
- Schema initialization
- Table structure verification
- Index existence verification

### Unit Tests (test/test_queries.jl)

**Projects:**
- Create project with required fields
- Create project with all fields
- Create duplicate project (expect error)
- Get project by id
- Get non-existent project (returns nothing)
- List projects (empty and populated)
- Update project fields
- Delete project

**Categories:**
- Create category
- Create duplicate category (expect error)
- Get category
- List categories
- Update category
- Delete category

**Todos:**
- Create todo with minimal fields
- Create todo with all fields
- Create todo with project
- Create todo with category
- Create todo with invalid project_id (expect error)
- Create todo with invalid status (expect error)
- Create todo with invalid priority (expect error)
- Create todo with invalid date format (expect error)
- Get todo
- List todos
- Update todo
- Complete todo (verify status and completed_at)
- Delete todo

**Filtering:**
- Filter by status (multiple statuses)
- Filter by project
- Filter by category
- Filter by date range
- Combined filters (status + project)
- Empty results (return [])

### Integration Tests
- Complete workflow: create project, category, todo; update; delete
- Cascading deletes: delete project, verify todos' project_id becomes NULL
- Foreign key enforcement: try to create todo with bad project_id

### Manual Tests
- [ ] Run install.jl, verify ~/.todo-list/todos.db created
- [ ] Open database in SQLite browser, inspect schema
- [ ] Run demo.jl, verify data appears
- [ ] Run tests in Docker: ./scripts/docker-test
- [ ] Verify no database files in git status

## Notes

### Implementation Order
Follow the steps sequentially. Each step builds on previous steps and should be tested before moving to the next.

### Stashed Work
There is existing implementation in the stash (2251 lines). Review and incorporate if sound, otherwise follow this plan from scratch.

### Key Technical Details
- **String keys for SQLite:** Always use `row["column"]` not `row[:column]`
- **Foreign keys:** Must execute `PRAGMA foreign_keys = ON` after every connection
- **Timestamps:** Update `updated_at` explicitly in Julia code (no DB triggers)
- **Parameterized queries:** Always use DBInterface with parameter binding
- **Cross-platform paths:** Use `homedir()` and `joinpath()`
- **Test databases:** Always use `:memory:` for tests

### Testing Philosophy
- Test early and often (after each step)
- Use :memory: databases (fast, no cleanup needed)
- Test both success and failure cases
- Verify error messages are helpful
- Test with empty database and populated database

### Performance Considerations
- Indexes created for common query patterns
- SQLite is very fast for our expected scale (< 10,000 todos)
- :memory: tests are instant
- No premature optimization needed

### Future Extensibility
This database layer is designed to be extended with:
- TUI interface (Phase 4+)
- Additional query methods as needed
- Statistics and analytics functions
- Gantt chart data export
- Migration system (if schema changes needed)

---

**Plan Complete**

This plan breaks Phase 3 into 13 incremental, testable steps. Each step has clear deliverables, tests, and success criteria. The implementation follows CLAUDE.md rules and uses the approved technology stack.
